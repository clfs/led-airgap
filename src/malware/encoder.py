#!/usr/bin/env python3
"""Docstring"""

import sys
from math import ceil
from bitarray import bitarray
import reedsolo

BARKER = bitarray('1111100110101')
RS_CODEC_32 = reedsolo.RSCodec(4)
RS_CODEC_128 = reedsolo.RSCodec(16)

def main():
    """Docstring"""
    # SETUP #
    # Get the content from pipe, strip trailing whitespace
    stdin_content = ''.join(line for line in sys.stdin).rstrip()
    # Will hold BFSK data
    bfsk = bitarray()

    # HEADER #
    # Add 13-bit Barker code
    bfsk.extend(BARKER)
    # Add content length in bytes, encoded using Reed-Solomon
    clib = len(stdin_content).to_bytes(2, byteorder='big')
    rs_clib = RS_CODEC_32.encode(clib)
    rs_clib_str = ''.join('{0:08b}'.format(byte) for byte in rs_clib)
    bfsk.extend(rs_clib_str)

    # DATA #
    # Determine number of packets
    num_packets = ceil(len(stdin_content)/16)
    # Loop through content, generating and extending with packets
    for i in range(num_packets):
        # Add 13-bit Barker code
        bfsk.extend(BARKER)
        # Find the bounds on the packet content
        start_byte = i*16
        end_byte = (i+1)*16
        if end_byte > len(stdin_content):
            end_byte = len(stdin_content)
        # Grab the packet content
        packet_content = stdin_content[start_byte:end_byte]
        # Append the Reed-Solomon-coded content
        rs_pktcnt = RS_CODEC_128.encode(packet_content)
        rs_pktcnt_str = ''.join('{0:08b}'.format(byte) for byte in rs_pktcnt)
        bfsk.extend(rs_pktcnt_str)

    print(bfsk)
    return

if __name__ == "__main__":
    main()
